"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getFilteredNodesXToY(tapeNodes, xs, y) {
    var arraysFromX = {};
    for (var i = 0; i < xs.length; i++) {
        arraysFromX[xs[i].id] = true;
    }
    for (var i = 0; i < tapeNodes.length; i++) {
        var node = tapeNodes[i];
        var nodeInputs = node.inputAndArgs.inputs;
        for (var inputName in nodeInputs) {
            var input = nodeInputs[inputName];
            for (var j = 0; j < xs.length; j++) {
                if (arraysFromX[input.id]) {
                    arraysFromX[node.output.id] = true;
                    break;
                }
            }
            if (arraysFromX[node.output.id]) {
                break;
            }
        }
    }
    var arraysLeadToY = {};
    arraysLeadToY[y.id] = true;
    for (var i = tapeNodes.length - 1; i >= 0; i--) {
        var node = tapeNodes[i];
        var nodeInputs = node.inputAndArgs.inputs;
        if (arraysLeadToY[node.output.id]) {
            for (var inputName in nodeInputs) {
                arraysLeadToY[nodeInputs[inputName].id] = true;
            }
        }
    }
    var filteredTapeNodes = [];
    for (var i = 0; i < tapeNodes.length; i++) {
        var node = tapeNodes[i];
        if (arraysFromX[node.output.id] && arraysLeadToY[node.output.id]) {
            var prunedInputs = {};
            for (var inputName in node.inputAndArgs.inputs) {
                var nodeInput = node.inputAndArgs.inputs[inputName];
                if (arraysFromX[nodeInput.id]) {
                    prunedInputs[inputName] = nodeInput;
                }
            }
            var prunedNode = Object.assign({}, node);
            prunedNode.inputAndArgs = { inputs: prunedInputs };
            filteredTapeNodes.push(prunedNode);
        }
    }
    return filteredTapeNodes;
}
exports.getFilteredNodesXToY = getFilteredNodesXToY;
function backpropagateGradients(backend, arrayAccumulatedGradientMap, filteredNodes) {
    for (var i = filteredNodes.length - 1; i >= 0; i--) {
        var node = filteredNodes[i];
        var dy = arrayAccumulatedGradientMap[node.output.id];
        if (node.gradient == null) {
            throw new Error("Cannot compute gradient: gradient function not found for\n              " + node.name + ".");
        }
        var inputGradients = node.gradient(dy, node.output);
        for (var inputName in node.inputAndArgs.inputs) {
            if (!(inputName in inputGradients)) {
                throw new Error("Cannot backprop through input " +
                    (node.name + "." + inputName + ". Gradients found: ") +
                    (Object.keys(inputGradients) + "."));
            }
            var grad = inputGradients[inputName]();
            var activation = node.inputAndArgs.inputs[inputName];
            if (arrayAccumulatedGradientMap[activation.id] == null) {
                arrayAccumulatedGradientMap[activation.id] = grad;
            }
            else {
                var curGradient = arrayAccumulatedGradientMap[activation.id];
                arrayAccumulatedGradientMap[activation.id] =
                    backend.add(curGradient, grad);
                curGradient.dispose();
            }
        }
    }
}
exports.backpropagateGradients = backpropagateGradients;
