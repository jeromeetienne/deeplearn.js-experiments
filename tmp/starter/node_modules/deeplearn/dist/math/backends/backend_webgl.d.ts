import { Conv2DInfo } from '../conv_util';
import { NDArrayMath } from '../math';
import { Array1D, Array2D, Array3D, Array4D, DataTypes, NDArray } from '../ndarray';
import { SumTypes } from '../types';
import { MathBackend } from './backend';
import { MatrixOrientation } from './types/matmul';
import { GPGPUContext } from './webgl/gpgpu_context';
import { TextureData } from './webgl/tex_util';
import { TextureManager } from './webgl/texture_manager';
export declare class MathBackendWebGL implements MathBackend {
    private texData;
    writePixels(id: number, pixels: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, numChannels: number): void;
    write<T extends keyof DataTypes>(id: number, values: DataTypes[T], dtype: T, shape: number[]): void;
    readSync<T extends keyof DataTypes>(id: number): DataTypes[T];
    read<T extends keyof DataTypes>(id: number): Promise<DataTypes[T]>;
    time(query: () => NDArray): Promise<number>;
    disposeData(id: number): void;
    getTexture(id: number): WebGLTexture;
    getTextureData(id: number): TextureData;
    private gpgpu;
    private textureManager;
    private binaryCache;
    private gpgpuCreatedLocally;
    constructor(gpgpu?: GPGPUContext);
    getGPGPUContext(): GPGPUContext;
    clone<G extends keyof DataTypes, T extends NDArray<G>>(x: T): T;
    slice1D(x: Array1D, begin: number, size: number): Array1D;
    slice2D(x: Array2D, begin: [number, number], size: [number, number]): Array2D;
    slice3D(x: Array3D, begin: [number, number, number], size: [number, number, number]): Array3D;
    slice4D(x: Array4D, begin: [number, number, number, number], size: [number, number, number, number]): Array4D;
    private copy2D(source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol);
    concat1D(a: Array1D, b: Array1D): Array1D;
    concat2D(a: Array2D, b: Array2D, axis: number): Array2D;
    concat3D(a: Array3D, b: Array3D, axis: number): Array3D;
    concat4D(a: Array4D, b: Array4D, axis: number): Array4D;
    neg<T extends NDArray>(x: T): T;
    matMul(a: Array2D, b: Array2D, aOrientation: MatrixOrientation, bOrientation: MatrixOrientation): Array2D;
    multiply<T extends NDArray>(a: T, b: T): T;
    batchNormalization2D(x: Array2D, mean: Array2D | Array1D, variance: Array2D | Array1D, varianceEpsilon: number, scale?: Array2D | Array1D, offset?: Array2D | Array1D): Array2D;
    batchNormalization3D(x: Array3D, mean: Array3D | Array1D, variance: Array3D | Array1D, varianceEpsilon: number, scale?: Array3D | Array1D, offset?: Array3D | Array1D): Array3D;
    tile<D extends keyof DataTypes, T extends NDArray<D>>(x: T, reps: number[]): T;
    transpose<D extends keyof DataTypes, T extends NDArray<D>>(x: T, perm: number[]): T;
    private reduce<D>(x, reduceType, dtype);
    private argReduce(x, reduceType, bestIndicesA?);
    sum<T extends keyof DataTypes>(x: NDArray<T>, axes: number[]): NDArray<SumTypes[T]>;
    argMin(x: NDArray, axes: number[]): NDArray<'int32'>;
    argMax(x: NDArray, axes: number[]): NDArray<'int32'>;
    equal(a: NDArray, b: NDArray): NDArray<'bool'>;
    topKValues<D extends keyof DataTypes, T extends NDArray<D>>(x: T, k: number): Array1D<D>;
    topKIndices(x: NDArray, k: number): Array1D<'int32'>;
    min<G extends keyof DataTypes>(x: NDArray<G>, axes: number[]): NDArray<G>;
    max<G extends keyof DataTypes>(x: NDArray<G>, axes: number[]): NDArray<G>;
    divide(a: NDArray, b: NDArray): NDArray<'float32'>;
    add<T extends NDArray>(a: T, b: T): T;
    subtract<T extends NDArray>(a: T, b: T): T;
    pow<T extends NDArray>(a: T, b: NDArray<'int32'>): T;
    ceil<T extends NDArray>(x: T): T;
    floor<T extends NDArray>(x: T): T;
    exp<T extends NDArray>(x: T): T;
    log<T extends NDArray>(x: T): T;
    sqrt<T extends NDArray>(x: T): T;
    square<T extends NDArray>(x: T): T;
    relu<T extends NDArray>(x: T): T;
    elu<T extends NDArray>(x: T): T;
    eluDer<T extends NDArray>(x: T): T;
    selu<T extends NDArray>(x: T): T;
    leakyRelu<T extends NDArray>(x: T, alpha: number): T;
    prelu<T extends NDArray>(a: T, b: T): T;
    preluDer<T extends NDArray>(a: T, b: T): T;
    clip<T extends NDArray>(x: T, min: number, max: number): T;
    abs<T extends NDArray>(x: T): T;
    sigmoid<T extends NDArray>(x: T): T;
    sin<T extends NDArray>(x: T): T;
    cos<T extends NDArray>(x: T): T;
    tan<T extends NDArray>(x: T): T;
    asin<T extends NDArray>(x: T): T;
    acos<T extends NDArray>(x: T): T;
    atan<T extends NDArray>(x: T): T;
    sinh<T extends NDArray>(x: T): T;
    cosh<T extends NDArray>(x: T): T;
    tanh<T extends NDArray>(x: T): T;
    step<T extends NDArray>(x: T, alpha: number): T;
    conv2d(x: Array4D, filter: Array4D, bias: Array1D | null, convInfo: Conv2DInfo): Array4D;
    conv2dDerInput(dy: Array4D, filter: Array4D, convInfo: Conv2DInfo): Array4D;
    conv2dDerFilter(x: Array4D, dy: Array4D, convInfo: Conv2DInfo): Array4D;
    conv2dDerBias(dy: Array4D): Array1D;
    depthwiseConv2D(x: Array4D, filter: Array4D, convInfo: Conv2DInfo): Array4D;
    maxPool(x: Array4D, convInfo: Conv2DInfo): Array4D;
    minPool(x: Array4D, convInfo: Conv2DInfo): Array4D;
    avgPool(x: Array4D, convInfo: Conv2DInfo): Array4D;
    maxPoolBackprop(dy: Array4D, x: Array4D, convInfo: Conv2DInfo): Array4D;
    resizeBilinear3D(x: Array3D, newShape2D: [number, number], alignCorners: boolean): Array3D;
    multinomial(probs: Array2D, numSamples: number, seed: number): Array2D<'int32'>;
    oneHot(indices: Array1D, depth: number, onValue: number, offValue: number): Array2D;
    private makeOutputArray<G, T>(shape, dtype);
    private compileAndRun<T, K>(program, inputs, output?, customSetup?);
    private getAndSaveBinary(key, getBinary);
    getTextureManager(): TextureManager;
    dispose(): void;
    private throwIfNoData(id);
}
export declare class NDArrayMathGPU extends NDArrayMath {
    constructor(gpgpu?: GPGPUContext, safeMode?: boolean);
    getGPGPUContext(): GPGPUContext;
    getTextureManager(): TextureManager;
}
