import { NDArrayMath } from './math';
import { RandNormalDataTypes } from './rand';
export declare enum DType {
    float32 = "float32",
    int32 = "int32",
    bool = "bool",
}
export interface DataTypes {
    float32: Float32Array;
    int32: Int32Array;
    bool: Uint8Array;
}
export interface NDArrayData<T extends keyof DataTypes> {
    id?: number;
    values?: DataTypes[T];
}
export declare class NDArray<T extends keyof DataTypes = keyof DataTypes> {
    static nextId: number;
    id: number;
    shape: number[];
    size: number;
    dtype: T;
    strides: number[];
    private math;
    protected constructor(shape: number[], dtype: T, values?: DataTypes[T], id?: number, math?: NDArrayMath);
    static ones<T extends keyof DataTypes = keyof DataTypes>(shape: number[], dtype?: T): NDArray<T>;
    static zeros<T extends keyof DataTypes = keyof DataTypes>(shape: number[], dtype?: T): NDArray<T>;
    static onesLike<G extends keyof DataTypes, T extends NDArray<G>>(another: T): T;
    static zerosLike<G extends keyof DataTypes, T extends NDArray<G>>(another: T): T;
    static like<G extends keyof DataTypes, T extends NDArray<G>>(another: T): T;
    static make<T extends keyof DataTypes = keyof DataTypes>(shape: number[], data: NDArrayData<T>, dtype?: T, math?: NDArrayMath): NDArray<T>;
    static fromPixels(pixels: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, numChannels?: number, math?: NDArrayMath): Array3D<'int32'>;
    reshape(newShape: number[]): NDArray<T>;
    flatten(): Array1D<T>;
    asScalar(): Scalar<T>;
    as1D(): Array1D<T>;
    as2D(rows: number, columns: number): Array2D<T>;
    as3D(rows: number, columns: number, depth: number): Array3D<T>;
    as4D(rows: number, columns: number, depth: number, depth2: number): Array4D<T>;
    asType<G extends keyof DataTypes>(dtype: G): NDArray<G>;
    readonly rank: number;
    get(...locs: number[]): number;
    add(value: number, ...locs: number[]): void;
    set(value: number, ...locs: number[]): void;
    val(...locs: number[]): Promise<number>;
    locToIndex(locs: number[]): number;
    indexToLoc(index: number): number[];
    fill(value: number): void;
    getValues(): DataTypes[T];
    getValuesAsync(): Promise<DataTypes[T]>;
    data(): Promise<DataTypes[T]>;
    dataSync(): DataTypes[T];
    dispose(): void;
    equals(t: NDArray<T>): boolean;
    static rand<T extends keyof DataTypes>(shape: number[], randFunction: () => number, dtype?: T): NDArray<T>;
    static randNormal<T extends keyof RandNormalDataTypes>(shape: number[], mean?: number, stdDev?: number, dtype?: T, seed?: number): NDArray<T>;
    static randTruncatedNormal<T extends keyof RandNormalDataTypes>(shape: number[], mean?: number, stdDev?: number, dtype?: T, seed?: number): NDArray<T>;
    static randUniform<T extends keyof DataTypes>(shape: number[], a: number, b: number, dtype?: T): NDArray<T>;
    private isDisposed;
    private throwIfDisposed();
}
export declare class Scalar<T extends keyof DataTypes = keyof DataTypes> extends NDArray<T> {
    static new<T extends keyof DataTypes = keyof DataTypes>(value: number | boolean, dtype?: T): Scalar<T>;
    get(): number;
    val(): Promise<number>;
    add(value: number): void;
    asType<G extends keyof DataTypes>(dtype: G): Scalar<G>;
    locToIndex(loc: number[]): number;
    indexToLoc(index: number): number[];
}
export declare class Array1D<T extends keyof DataTypes = keyof DataTypes> extends NDArray<T> {
    shape: [number];
    static new<T extends keyof DataTypes = keyof DataTypes>(values: DataTypes[T] | number[] | boolean[], dtype?: T): Array1D<T>;
    get(i: number): number;
    val(i: number): Promise<number>;
    add(value: number, i: number): void;
    locToIndex(loc: [number]): number;
    indexToLoc(index: number): [number];
    asType<G extends keyof DataTypes>(dtype: G): Array1D<G>;
    static ones<T extends keyof DataTypes = keyof DataTypes>(shape: [number], dtype?: T): Array1D<T>;
    static zeros<T extends keyof DataTypes = keyof DataTypes>(shape: [number], dtype?: T): Array1D<T>;
    static randNormal<T extends keyof RandNormalDataTypes>(shape: [number], mean?: number, stdDev?: number, dtype?: T, seed?: number): Array1D<T>;
    static randTruncatedNormal<T extends keyof RandNormalDataTypes>(shape: [number], mean?: number, stdDev?: number, dtype?: T, seed?: number): Array1D<T>;
    static randUniform<T extends keyof DataTypes>(shape: [number], a: number, b: number, dtype?: T): Array1D<T>;
}
export declare class Array2D<T extends keyof DataTypes = keyof DataTypes> extends NDArray<T> {
    shape: [number, number];
    private stride0;
    constructor(shape: [number, number], dtype: T, values?: DataTypes[T], id?: number, math?: NDArrayMath);
    static new<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number], values: DataTypes[T] | number[] | number[][] | boolean[] | boolean[][], dtype?: T): Array2D<T>;
    get(i: number, j: number): number;
    add(value: number, i: number, j: number): void;
    val(i: number, j: number): Promise<number>;
    locToIndex(locs: [number, number]): number;
    indexToLoc(index: number): [number, number];
    asType<G extends keyof DataTypes>(dtype: G): Array2D<G>;
    static ones<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number], dtype?: T): Array2D<T>;
    static zeros<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number], dtype?: T): Array2D<T>;
    static randNormal<T extends keyof RandNormalDataTypes>(shape: [number, number], mean?: number, stdDev?: number, dtype?: T, seed?: number): Array2D<T>;
    static randTruncatedNormal<T extends keyof RandNormalDataTypes>(shape: [number, number], mean?: number, stdDev?: number, dtype?: T, seed?: number): Array2D<T>;
    static randUniform<T extends keyof DataTypes>(shape: [number, number], a: number, b: number, dtype?: T): Array2D<T>;
}
export declare class Array3D<T extends keyof DataTypes = keyof DataTypes> extends NDArray<T> {
    shape: [number, number, number];
    private stride0;
    private stride1;
    constructor(shape: [number, number, number], dtype: T, values?: DataTypes[T], id?: number, math?: NDArrayMath);
    static new<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number, number], values: DataTypes[T] | number[] | number[][][] | boolean[] | boolean[][][], dtype?: T): Array3D<T>;
    get(i: number, j: number, k: number): number;
    val(i: number, j: number, k: number): Promise<number>;
    add(value: number, i: number, j: number, k: number): void;
    locToIndex(locs: [number, number, number]): number;
    indexToLoc(index: number): [number, number, number];
    asType<G extends keyof DataTypes>(dtype: G): Array3D<G>;
    static ones<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number, number], dtype?: T): Array3D<T>;
    static zeros<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number, number], dtype?: T): Array3D<T>;
    static randNormal<T extends keyof RandNormalDataTypes>(shape: [number, number, number], mean?: number, stdDev?: number, dtype?: T, seed?: number): Array3D<T>;
    static randTruncatedNormal<T extends keyof RandNormalDataTypes>(shape: [number, number, number], mean?: number, stdDev?: number, dtype?: T, seed?: number): Array3D<T>;
    static randUniform<T extends keyof DataTypes>(shape: [number, number, number], a: number, b: number, dtype?: T): Array3D<T>;
}
export declare class Array4D<T extends keyof DataTypes = keyof DataTypes> extends NDArray<T> {
    shape: [number, number, number, number];
    private stride0;
    private stride1;
    private stride2;
    constructor(shape: [number, number, number, number], dtype: T, values?: DataTypes[T], id?: number, math?: NDArrayMath);
    static new<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number, number, number], values: DataTypes[T] | number[] | number[][][][] | boolean[] | boolean[][][][], dtype?: T): Array4D<T>;
    get(i: number, j: number, k: number, l: number): number;
    val(i: number, j: number, k: number, l: number): Promise<number>;
    add(value: number, i: number, j: number, k: number, l: number): void;
    locToIndex(locs: [number, number, number, number]): number;
    indexToLoc(index: number): [number, number, number, number];
    asType<G extends keyof DataTypes>(dtype: G): Array4D<G>;
    static ones<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number, number, number], dtype?: T): Array4D<T>;
    static zeros<T extends keyof DataTypes = keyof DataTypes>(shape: [number, number, number, number], dtype?: T): Array4D<T>;
    static randNormal<T extends keyof RandNormalDataTypes>(shape: [number, number, number, number], mean?: number, stdDev?: number, dtype?: T, seed?: number): Array4D<T>;
    static randTruncatedNormal<T extends keyof RandNormalDataTypes>(shape: [number, number, number, number], mean?: number, stdDev?: number, dtype?: T, seed?: number): Array4D<T>;
    static randUniform<T extends keyof DataTypes>(shape: [number, number, number, number], a: number, b: number, dtype?: T): Array4D<T>;
}
